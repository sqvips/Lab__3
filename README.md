# LabN3
## Отчет по лабораторной работе № 3

#### № группы: `ПМ-2402`

#### Выполнил: `Савушкин Павел Павлович`

#### Вариант: `21`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Почему я разделил задачу на данные классы](#2-классы)
- [Описание](#3-описание)

### 1. Постановка задачи

- Условия задачи
  > Передо мной стояла задача разработать программу для работы с взвешенным графом, представленным рёбрами с начальной и конечной вершинами и весом. Также реализовать некоторые, нижеперечисленные функции для работы с ним.

### 2. Классы

Мы знаем, что каждый класс отвечает за конкретную задачу, разделяя большую программу на несколько маленьких. Я сделал также, разделив программу на четыре "части". Так, например, класс `Edge` управляет рёбрами графа, класс `Graph` управляет логикой работы с графом (добавление, удаление рёбер, объединение и т.д.), а класс `GraphDisplay` отвечает за отображение информации о графе. Последним же - является главный класс для запуска программы, одновременно являющийся тестовой программой.
Теперь немного подробнее.
1. Класс `Edge`:
Представление рёбер: Класс Edge отвечает за представление рёбер графа. Ребро связывает две вершины и имеет вес. Этот класс инкапсулирует все необходимые данные о ребре (две вершины и вес) и методы для работы с ними.
Упрощение работы с рёбрами: Наличие отдельного класса для рёбер позволяет легко управлять их свойствами и методами (например, изменение веса, сравнение рёбер и т.д.).
2. Класс `Graph`:
Логика графа: Класс Graph отвечает за основную логику работы с графом, включая добавление, удаление и изменение рёбер. Этот класс управляет коллекцией рёбер и реализует алгоритмы, связанные с графами (например, объединение графов, удаление вершин и т.д.).
Инкапсуляция данных: Класс Graph инкапсулирует логику работы с рёбрами. Пользователь может добавлять рёбра и выполнять операции над графом, не беспокоясь о внутренней реализации.
3. Класс `GraphDisplay`:
Отображение данных: Класс GraphDisplay отвечает исключительно за отображение информации о графе. Он содержит методы для вывода рёбер, вершин и сортировки. Это разделение позволяет отделить логику отображения от логики работы с данными.
Упрощение визуализации: Наличие отдельного класса для отображения упрощает изменение способа вывода данных (например, можно легко изменить формат вывода или добавить графический интерфейс), не затрагивая логику работы с графом.

### 3. Описание

Как было написано в рекомендациях к выполнению, разберу математические модели, но чуть позже. В этот раз мы учтем тестовый класс `Main`.

1. Класс `Edge`:

В моем классе Edge я определил три поля: две вершины, которые соединены ребром (top1 и top2), и вес этого ребра (weight). Я сделал вершины final, чтобы их значения нельзя было изменить после инициализации, так как это важно для сохранения целостности данных о ребре.

В конструкторе я принимаю две вершины и вес ребра. Используя Math.min и Math.max, я устанавливаю порядок вершин, чтобы гарантировать, что top1 всегда меньше или равен top2. Это упрощает работу с ребрами, так как я избегаю дублирования информации о ребре, соединяющем одни и те же вершины.

Я также добавил геттеры для доступа к вершинам и весу ребра. Это позволяет другим классам получать информацию о ребре, не имея возможности напрямую изменять его состояние.

Для изменения веса ребра я реализовал сеттер. Перед установкой нового значения проверяя, не является ли оно отрицательным. Если вес оказывается отрицательным, я вывожу сообщение об ошибке. Это важно для поддержания целостности данных, так как вес ребра не может быть отрицательным.

Кроме того, я переопределил метод toString, чтобы предоставить удобное представление ребра в виде строки. Это позволяет легко выводить информацию о ребре, например, в логах или на экране. Формат строки показывает, какие вершины соединены ребром и какой у него вес, что делает его полезным для отладки и визуализации.

2. Класс `Graph`:

В моем классе Graph я определил несколько полей и методов для работы с графами. Граф представляет собой коллекцию рёбер, соединяющих вершины. Каждое ребро имеет вес, который может быть изменен или объединен с другими рёбрами.

Конструктор графа инициализирует пустой список рёбер.

Метод `getEdges` позволяет получить список всех рёбер графа.

Метод `addEdge` добавляет новое ребро в граф. Если вершины ребра совпадают, то ребро не добавляется в граф. Метод добавляет новое ребро между вершинами top1 и top2 с заданным весом weight. Если top1 и top2 совпадают, метод завершает выполнение, предотвращая создание петли. В противном случае создаётся новый объект Edge и добавляется в список edges.

Метод `combineEdges` объединяет все рёбра между двумя вершинами в одно ребро с общим весом. Если таких рёбер нет, метод выводит сообщение об ошибке. Этот метод объединяет все рёбра между вершинами top_1 и top_2. Он сначала собирает все рёбра, которые соединяют эти вершины, в список edgesToCombine и суммирует их веса в totalWeight. Если рёбер для объединения не найдено, выводится сообщение об ошибке. В противном случае он удаляет только первое найденное ребро и вставляет новое ребро на его место.

Метод `combineEdges2` также предназначен для объединения рёбер между двумя вершинами top_1 и top_2, но его логика работы отличается от метода combineEdges. Сначала метод собирает все рёбра, соединяющие вершины top_1 и top_2, в список edgesToCombine. Он перебирает все рёбра в графе и проверяет, соединяют ли они указанные вершины. Если ребро соединяет эти вершины, оно добавляется в edgesToCombine, а его вес суммируется в переменной totalWeight. После завершения перебора метод проверяет, были ли найдены какие-либо рёбра для объединения. Если список edgesToCombine пуст, метод выводит сообщение об ошибке, информируя о том, что рёбер для объединения между указанными вершинами не найдено. Если рёбра были найдены, метод создает новое ребро с общим весом, используя значение totalWeight, и вершинами top_1 и top_2. В отличие от метода combineEdges, который удаляет все найденные рёбра, метод combineEdges2 удаляет только первое найденное ребро из списка рёбер. После этого новое ребро добавляется в граф на место удалённого.

Метод `changeEdgeWeight` изменяет вес ребра между двумя вершинами. Метод changeEdgeWeight изменяет вес ребра между вершинами top_1 и top_2 на значение weightNew. Он проходит по всем рёбрам и проверяет, существует ли ребро между указанными вершинами. Если вес, полученный после изменения, становится отрицательным, выводится сообщение об ошибке. В противном случае вес ребра обновляется.

Метод `removeEdgesBetween` удаляет все рёбра между двумя вершинами. Метод removeEdgesBetween удаляет все рёбра между двумя вершинами top_1 и top_2. Он проходит по списку рёбер в обратном порядке, чтобы избежать ошибок при изменении размера списка во время его обхода. Если находится ребро между указанными вершинами, оно удаляется из списка edges.

Метод `removeTops` удаляет все рёбра, связанные с заданной вершиной. Он также проходит по списку рёбер в обратном порядке, чтобы избежать ошибок при удалении. Если ребро связано с указанной вершиной, оно удаляется из списка edges. 

Метод `removeTopsMinMax` удаляет вершины с максимальным весом входящих рёбер и минимальным количеством входящих рёбер. Он использует два массива: incomingWeights для хранения суммарного веса входящих рёбер и incomingCounts для подсчёта количества входящих рёбер для каждой вершины. После подсчёта максимального веса и минимального количества входящих рёбер, метод проходит по всем вершинам и удаляет те, которые соответствуют критериям.

Метод `combine` объединяет рёбра из другого графа newGraph с текущим графом. Он проходит по всем рёбрам нового графа и проверяет, существуют ли такие же рёбра в текущем графе. Если ребро найдено, его вес увеличивается на вес нового ребра. Если ребро не найдено, создаётся новое ребро и добавляется в список edges.

3. Класс `GraphDisplay`:

Для работы с графом сделаем конструктор, принимающий объект Graph и инициализирующий поле graph.

Метод `show` выводит информацию о каждом ребре графа. Он проходит по всем рёбрам, полученным с помощью метода getEdges класса Graph, и выводит их на экран.

Метод `showTop` отображает все вершины графа. Он использует массив peak для отслеживания, какие вершины присутствуют в графе. Проходя по всем рёбрам, метод отмечает наличие каждой вершины. Затем он выводит все отмеченные вершины в порядке убывания, начиная с 1000 до 0.

Метод `showTop2Limit` предназначен для анализа графа и вывода вершин, у которых общий вес входящих рёбер не превышает указанного значения. Сначала он инициализирует массив top2Weight размером 1001 для хранения суммарных весов входящих рёбер для каждой из вершин графа. Затем метод проходит через все рёбра графа, извлекая информацию о каждой паре связанных вершин и соответствующих весах рёбер. Для каждого ребра он добавляет вес к элементам массива top2Weight, соответствующим обеим вершинам, таким образом учитывая вклад каждого ребра в общий вес входящих рёбер. После завершения подсчёта весов метод перебирает массив top2Weight и выводит номера вершин, у которых общий вес входящих рёбер не превышает заданное значение value.

Метод `showTopsSortedWeight` отображает вершины, отсортированные по весу входящих рёбер. Сначала он подсчитывает суммарный вес входящих рёбер для каждой вершины, используя массив top2Weight. Затем он заполняет массив topX, который хранит индексы вершин. Метод использует сортировку пузырьком для сортировки вершин по весу входящих рёбер, а затем выводит отсортированные вершины на экран. 

4. Класс `Main`:

Как я уже сказал, в нашем случае этот класс будем рассматриват как тестовый. Единственная проблема - тяжело рассмотреть все случаи. Поэтому я постарался подобрать такие ребра, чтобы задействовать все методы.
Создадим два новых граф: Graph graph = new Graph(); и Graph graph1 = new Graph();

Добавим данные с помощью метода addEdge();
Рёбра и вес первого графа:
(1, 2) - 10;
(2, 3) - 5;
(1, 3) - 15;
(2, 1) - 8;
(4, 5) - 19;
(3, 4) - 12;
(5, 1) - 6;
(2, 4) - 11;
(3, 5) - 9;
(1, 4) - 14;
(2, 5) - 20;
(4, 6) - 30;
(6, 7) - 25;
(7, 1) - 5;

Рёбра и вес второго графа:
(5, 1) - 6;
(100, 65) - 1;

Первый граф выглядит так:
![image](https://github.com/user-attachments/assets/d85ce7e2-0000-4742-be74-0f512d01ce11)

1. graphDisplay.show(); - показываем граф

   **Output**:
      ```
    1 - 2 (10)
    2 - 3 (5)
    1 - 3 (15)
    1 - 2 (8)
    4 - 5 (19)
    3 - 4 (12)
    1 - 5 (6)
    2 - 4 (11)
    3 - 5 (9)
    1 - 4 (14)
    2 - 5 (20)
    4 - 6 (30)
    6 - 7 (25)
    1 - 7 (5)  
      ```

      
2. graphDisplay.showTop(); - показываем в порядке убывания вершины

   **Output**:
      ```
    7
    6
    5
    4
    3
    2
    1
      ```
      
3. graphDisplay.showTop2Limit(30); - показываем вершины, сумма ребер входящих в которую меньше указанного значения.

   **Output**:
      ```
    7
      ```

4. graphDisplay.showTopsSortedWeight(); - по весу сортировка вершин

   **Output**:
      ```
    5
    4
    7
    6
    3
    2
      ```

5. graph.combineEdges2(1, 2); - прибавляем все (1, 2) и (2, 1) К первой паре (1, 2). Осталные ребра не удаляются
        graphDisplay.show();

   **Output**:
      ```
    1 - 2 (18)
    2 - 3 (5)
    1 - 3 (15)
    1 - 2 (8)
    4 - 5 (19)
    3 - 4 (12)
    1 - 5 (6)
    2 - 4 (11)
    3 - 5 (9)
    1 - 4 (14)
    2 - 5 (20)
    4 - 6 (30)
    6 - 7 (25)
    1 - 7 (5)
      ```
6. graph.combineEdges(1, 2); - Аналогично 5ому пункту проверки, однак остальные пары выбрасываются (кроме 1)
        graphDisplay.show();

   **Output**:
      ```
    1 - 2 (26)
    2 - 3 (5)
    1 - 3 (15)
    4 - 5 (19)
    3 - 4 (12)
    1 - 5 (6)
    2 - 4 (11)
    3 - 5 (9)
    1 - 4 (14)
    2 - 5 (20)
    4 - 6 (30)
    6 - 7 (25)
    1 - 7 (5)
      ```
7. graph.changeEdgeWeight(1, 2, 5); - прибавляем к (1, 2) пять
        graphDisplay.show();
   **Output**:
      ```
    1 - 2 (31)
    2 - 3 (5)
    1 - 3 (15)
    4 - 5 (19)
    3 - 4 (12)
    1 - 5 (6)
    2 - 4 (11)
    3 - 5 (9)
    1 - 4 (14)
    2 - 5 (20)
    4 - 6 (30)
    6 - 7 (25)
    1 - 7 (5)
      ```
8. graph.removeEdgesBetween(1, 2); - выбрасываем (1, 2)
        graphDisplay.show();
   **Output**:
      ```
    2 - 3 (5)
    1 - 3 (15)
    4 - 5 (19)
    3 - 4 (12)
    1 - 5 (6)
    2 - 4 (11)
    3 - 5 (9)
    1 - 4 (14)
    2 - 5 (20)
    4 - 6 (30)
    6 - 7 (25)
    1 - 7 (5)
      ```
9. graph.removeTops(3); - выбрасываем вершину 3
        graphDisplay.show();
   **Output**:
      ```
    4 - 5 (19)
    1 - 5 (6)
    2 - 4 (11)
    1 - 4 (14)
    2 - 5 (20)
    4 - 6 (30)
    6 - 7 (25)
    1 - 7 (5)
      ```
10. graph.removeTopsMinMax(); -  удаляем вершины, у которых общий вес входящих рёбер максимален, а также вершины с минимальным количеством входящих рёбер
        graphDisplay.show();
    **Output**:
      ```
    1 - 5 (6)
      ```
    ![image](https://github.com/user-attachments/assets/442dbc70-f0ba-4633-bc86-7c69176e79c4)
  
11. graph.combine(graph1); - сливаем два графа по условию
        graphDisplay.show();
    **Output**:
      ```
    1 - 5 (12)
    65 - 100 (1)
      ```       
