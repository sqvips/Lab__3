# LabN3
## Отчет по лабораторной работе № 3

#### № группы: `ПМ-2402`

#### Выполнил: `Савушкин Павел Павлович`

#### Вариант: `21`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Почему я разделил задачу на данные классы](#2-классы)
- [Описание](#3-описание)

### 1. Постановка задачи

- Условия задачи
  > Передо мной стояла задача разработать программу для работы с взвешенным графом, представленным рёбрами с начальной и конечной вершинами и весом. Также реализовать некоторые, нижеперечисленные функции для работы с ним.

### 2. Классы

Мы знаем, что каждый класс отвечает за конкретную задачу, разделяя большую программу на несколько маленьких. Я сделал также, разделив программу на четыре "части". Так, например, класс `Edge` управляет рёбрами графа, класс `Graph` управляет логикой работы с графом (добавление, удаление рёбер, объединение и т.д.), а класс `GraphDisplay` отвечает за отображение информации о графе. Последним же - является главный класс для запуска программы, одновременно являющийся тестовой программой.
Теперь немного подробнее.
1. Класс `Edge`:
Представление рёбер: Класс Edge отвечает за представление рёбер графа. Ребро связывает две вершины и имеет вес. Этот класс инкапсулирует все необходимые данные о ребре (две вершины и вес) и методы для работы с ними.
Упрощение работы с рёбрами: Наличие отдельного класса для рёбер позволяет легко управлять их свойствами и методами (например, изменение веса, сравнение рёбер и т.д.).
2. Класс `Graph`:
Логика графа: Класс Graph отвечает за основную логику работы с графом, включая добавление, удаление и изменение рёбер. Этот класс управляет коллекцией рёбер и реализует алгоритмы, связанные с графами (например, объединение графов, удаление вершин и т.д.).
Инкапсуляция данных: Класс Graph инкапсулирует логику работы с рёбрами. Пользователь может добавлять рёбра и выполнять операции над графом, не беспокоясь о внутренней реализации.
3. Класс `GraphDisplay`:
Отображение данных: Класс GraphDisplay отвечает исключительно за отображение информации о графе. Он содержит методы для вывода рёбер, вершин и сортировки. Это разделение позволяет отделить логику отображения от логики работы с данными.
Упрощение визуализации: Наличие отдельного класса для отображения упрощает изменение способа вывода данных (например, можно легко изменить формат вывода или добавить графический интерфейс), не затрагивая логику работы с графом.

### 3. Описание

Как было написано в рекомендациях к выполнению, разберу математические модели, но чуть позже. В этот раз мы учтем тестовый класс `Main`.

1. Класс `Edge`:

В моем классе Edge я определил три поля: две вершины, которые соединены ребром (top1 и top2), и вес этого ребра (weight). Я сделал вершины final, чтобы их значения нельзя было изменить после инициализации, так как это важно для сохранения целостности данных о ребре.

В конструкторе я принимаю две вершины и вес ребра. Используя Math.min и Math.max, я устанавливаю порядок вершин, чтобы гарантировать, что top1 всегда меньше или равен top2. Это упрощает работу с ребрами, так как я избегаю дублирования информации о ребре, соединяющем одни и те же вершины.

Я также добавил геттеры для доступа к вершинам и весу ребра. Это позволяет другим классам получать информацию о ребре, не имея возможности напрямую изменять его состояние.

Для изменения веса ребра я реализовал сеттер. Перед установкой нового значения проверяя, не является ли оно отрицательным. Если вес оказывается отрицательным, я вывожу сообщение об ошибке. Это важно для поддержания целостности данных, так как вес ребра не может быть отрицательным.

Кроме того, я переопределил метод toString, чтобы предоставить удобное представление ребра в виде строки. Это позволяет легко выводить информацию о ребре, например, в логах или на экране. Формат строки показывает, какие вершины соединены ребром и какой у него вес, что делает его полезным для отладки и визуализации.

2. Класс `Graph`:

В моем классе Graph я определил несколько полей и методов для работы с графами. Граф представляет собой коллекцию рёбер, соединяющих вершины. Каждое ребро имеет вес, который может быть изменен или объединен с другими рёбрами.

Конструктор графа инициализирует пустой список рёбер.
Метод `getEdges` позволяет получить список всех рёбер графа.

Метод `addEdge` добавляет новое ребро в граф. Если вершины ребра совпадают, метод не добавляет ребро в граф.

Метод `combineEdges` объединяет все рёбра между двумя вершинами в одно ребро с общим весом. Если таких рёбер нет, метод выводит сообщение об ошибке.

Метод `changeEdgeWeight` изменяет вес ребра между двумя вершинами. Если вес становится отрицательным, метод выводит сообщение об ошибке.

Метод `removeEdgesBetween` удаляет все рёбра между двумя вершинами.

Метод `removeTops` удаляет все рёбра, связанные с заданной вершиной.

Метод `removeTopsMinMax` удаляет вершины с максимальным весом и минимальным количеством входящих рёбер.

Метод `combine` объединяет рёбра из другого графа с рёбрами текущего графа.
